<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>GrouchoBarks Audio Player</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  <!-- TESTING ONLY - Load test token if it exists -->
  <script>
    fetch('./spotify-test-token.js')
      .then(response => response.ok ? response.text() : null)
      .then(script => script ? eval(script) : null)
      .catch(() => {}); // Silent fail if file doesn't exist
  </script>
  <!-- Spotify SDK callback MUST be defined before SDK loads -->
  <script>
    window.onSpotifyWebPlaybackSDKReady = () => {
      console.log('üéµ Spotify SDK ready');
      // Check if we have access token before initializing
      const token = sessionStorage.getItem('spotify_access_token');
      if (token && typeof window.initializeSpotifyPlayer === 'function') {
        window.initializeSpotifyPlayer();
      } else if (token) {
        console.log('üéµ SDK ready but initializeSpotifyPlayer not available yet');
        // Store that SDK is ready for later use
        window.spotifySDKReady = true;
      } else {
        console.log('üéµ SDK ready but no access token found');
      }
    };
  </script>
  <script src="https://sdk.scdn.co/spotify-player.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1db954, #191414);
      font-family: Arial, sans-serif;
      overflow-x: hidden;
      min-height: 100vh;
    }
    
    /* Game container - fixed size, no flex */
    #game {
      width: 528px;  /* 11 * 48px tiles */
      height: 500px;
      margin: 20px auto;
      border: 2px solid rgba(29, 185, 84, 0.3);
      border-radius: 8px;
      overflow: hidden;
      background: #363e48;
    }

    #music-bar {
      width: 528px;  /* Same width as game */
      height: 60px;
      background: linear-gradient(90deg, #1db954, #1ed760);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      box-sizing: border-box;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      border-radius: 10px;
      margin: 10px auto;
      z-index: 100;
    }
    
    .player-section {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .music-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .music-btn:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.1);
    }
    
    .music-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .track-info {
      color: white;
      font-size: 13px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    
    .user-info {
      color: white;
      font-size: 11px;
      opacity: 0.8;
    }
    
    .status {
      color: white;
      font-size: 12px;
      opacity: 0.9;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    @media (max-width: 768px) {
      .status {
        font-size: 14px;
        max-width: calc(100vw - 20px);
        top: 60px !important;
        left: 10px !important;
        right: 10px !important;
        white-space: normal;
        word-wrap: break-word;
      }
    }
    
    .hidden {
      display: none;
    }
    
    /* Inline Spotify Login */
    .spotify-login-inline {
      width: 528px;  /* Same width as game */
      text-align: center;
      margin: 10px auto;
      padding: 8px;
      box-sizing: border-box;
      background: rgba(29, 185, 84, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(29, 185, 84, 0.3);
    }
    
    .login-text {
      color: white;
      font-size: 13px;
      margin-right: 10px;
      opacity: 0.9;
    }
    
    .btn-small {
      padding: 6px 12px;
      border: none;
      border-radius: 12px;
      font-size: 12px;
      cursor: pointer;
      margin: 0 4px;
      transition: all 0.2s ease;
      background: #1db954;
      color: white;
      font-weight: 500;
    }
    
    .btn-small:hover {
      background: #1ed760;
      transform: scale(1.05);
    }
    
    .btn-small.skip {
      background: transparent;
      color: #b3b3b3;
      border: 1px solid #535353;
    }
    
    .btn-small.skip:hover {
      color: white;
      border-color: white;
      background: rgba(255, 255, 255, 0.1);
    }
    
    /* Player title */
    .player-title {
      color: white;
      font-size: 28px;
      font-weight: bold;
      text-align: center;
      margin: 20px 0 0 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    /* Compact login overlay */
    #login-overlay {
      background: rgba(0,0,0,0.9);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 2000;
      color: white;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    
    #login-overlay button {
      background: #1db954;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px;
    }
    
    #login-overlay button:hover {
      background: #1ed760;
    }
  </style>
</head>
<body>
  <!-- Player Title -->
  <h1 class="player-title">üéÆ GrouchoBarks Game <span style="font-size: 14px; opacity: 0.8;">v1.0.0</span></h1>
  
  <!-- Spotify Login Section (small and unobtrusive) -->
  <div id="spotify-login-section" class="spotify-login-inline">
    <span class="login-text">üéµ Want music?</span>
    <button id="spotify-login" class="btn-small">Connect Spotify</button>
    <button id="skip-spotify" class="btn-small skip">Skip</button>
  </div>
  
  <!-- Game Container -->
  <div id="game"></div>
  
  <!-- Simple Music Controls -->
  <div id="music-bar">
    <div class="player-section">
      <button id="play-btn" class="music-btn" title="Play">‚ñ∂Ô∏è</button>
      <button id="pause-btn" class="music-btn hidden" title="Pause">‚è∏Ô∏è</button>
      <button id="resume-btn" class="music-btn hidden" title="Resume">‚ñ∂Ô∏è</button>
    </div>
    
    <div class="track-info" id="track-info">
      Music Player v2.1.4 üéµ
    </div>
    
    <div class="player-section">
      <div class="user-info" id="user-info">üéß Ready</div>
    </div>
  </div>
  
  <script>
    // Version and browser info
    const MUSIC_VERSION = '2.1.4';
    const GAME_VERSION = '1.0.0';
    const BROWSER_INFO = {
      userAgent: navigator.userAgent,
      isMobile: false, // Temporarily disabled: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent),
      isIOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),
      isAndroid: /Android/i.test(navigator.userAgent),
      browser: (() => {
        const ua = navigator.userAgent.toLowerCase();
        if (ua.includes('chrome') && !ua.includes('edg')) return 'chrome';
        if (ua.includes('safari') && !ua.includes('chrome')) return 'safari';
        if (ua.includes('firefox')) return 'firefox';
        return 'other';
      })()
    };

    // External logging setup
    const LOG_ENDPOINT = `${window.location.origin}/log`; // Cloudflare Pages Function
    let logBuffer = [];
    
    async function sendToCloudflare(level, message, data = {}) {
      const logEntry = {
        timestamp: new Date().toISOString(),
        musicVersion: MUSIC_VERSION,
        gameVersion: GAME_VERSION,
        level,
        message,
        browser: BROWSER_INFO,
        url: window.location.href,
        data
      };
      
      logBuffer.push(logEntry);
      
      // Send to external service (enable when ready)
      try {
        await fetch(LOG_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(logEntry)
        });
      } catch (error) {
        // Silent fail - store locally instead
        localStorage.setItem('debug_logs', JSON.stringify(logBuffer.slice(-50))); // Keep last 50 entries
      }
    }

    // Define updateStatus early with logging (console only, no UI)
    function updateStatus(message, isError = false) {
      console.log(isError ? `‚ùå ${message}` : `‚úÖ ${message}`);
      
      // Send to external logging
      sendToCloudflare(isError ? 'error' : 'info', message);
    }
    // Spotify credentials
    const CLIENT_ID = 'aa16f7f72c04485fb93d86d2f7ee33d1';
    const REDIRECT_URI = 'https://frattypipeline.grouchobarks.bandmusicgames.party';
    const SCOPES = 'user-read-private user-read-email user-modify-playback-state user-read-playback-state streaming';
    const TEST_TRACK_URI = 'spotify:track:33lVSu93J91BDmhfRT7iTA';
    
    let accessToken = null;
    let spotifyPlayer = null;
    let deviceId = null;
    
    // Enhanced state tracking - GLOBAL scope so all functions can access
    let userPausedManually = false;
    let lastKnownPosition = 0;
    let pauseRequestTime = 0;
    let manualPauseProtectionTime = 0;
    
    // UI Elements - with null checks
    const spotifyLoginSection = document.getElementById('spotify-login-section');
    const musicBar = document.getElementById('music-bar');
    const spotifyLoginBtn = document.getElementById('spotify-login');
    const skipSpotifyBtn = document.getElementById('skip-spotify');
    const playBtn = document.getElementById('play-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resumeBtn = document.getElementById('resume-btn');
    
    // Debug: Log which elements were found
    console.log('UI Elements found:', {
      spotifyLoginSection: !!spotifyLoginSection,
      musicBar: !!musicBar,
      spotifyLoginBtn: !!spotifyLoginBtn,
      skipSpotifyBtn: !!skipSpotifyBtn,
      playBtn: !!playBtn,
      pauseBtn: !!pauseBtn,
      resumeBtn: !!resumeBtn
    });
    
    // updateStatus already defined above
    
    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const values = crypto.getRandomValues(new Uint8Array(length));
      return values.reduce((acc, x) => acc + possible[x % possible.length], "");
    }
    
    async function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return window.crypto.subtle.digest('SHA-256', data);
    }
    
    function base64encode(input) {
      return btoa(String.fromCharCode(...new Uint8Array(input)))
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
    }
    
    async function loginWithSpotify() {
      updateStatus('üéµ Starting login...');
      
      const codeVerifier = generateRandomString(64);
      const hashed = await sha256(codeVerifier);
      const codeChallenge = base64encode(hashed);
      
      localStorage.setItem('code_verifier', codeVerifier);
      
      const authUrl = new URL('https://accounts.spotify.com/authorize');
      authUrl.searchParams.append('response_type', 'code');
      authUrl.searchParams.append('client_id', CLIENT_ID);
      authUrl.searchParams.append('scope', SCOPES);
      authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
      authUrl.searchParams.append('code_challenge_method', 'S256');
      authUrl.searchParams.append('code_challenge', codeChallenge);
      
      window.location.href = authUrl.toString();
    }
    
    async function handleCallback() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      const error = urlParams.get('error');
      
      // Clear the URL immediately to prevent loops
      window.history.replaceState({}, document.title, window.location.pathname);
      
      if (error) {
        updateStatus(`‚ùå ${error}`, true);
        showPlayerOnly();
        return;
      }
      
      if (code) {
        updateStatus('üîë Getting token...');
        const success = await exchangeCodeForToken(code);
        if (success) {
          updateStatus('‚úÖ Connected! Initializing player...');
          getUserInfo();
        } else {
          updateStatus('‚ùå Login failed');
          showSpotifyLoginOption();
        }
      }
    }
    
    async function exchangeCodeForToken(code) {
      const codeVerifier = localStorage.getItem('code_verifier');
      
      if (!codeVerifier) {
        updateStatus('‚ùå No code verifier found', true);
        return false;
      }
      
      try {
        updateStatus('üîÑ Exchanging code for token...');
        
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Token failed: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        accessToken = data.access_token;
        
        sessionStorage.setItem('spotify_access_token', accessToken);
        localStorage.removeItem('code_verifier');
        
        updateStatus('‚úÖ Token OK');
        return true;
        
      } catch (error) {
        updateStatus(`‚ùå ${error.message}`, true);
        return false;
      }
    }
    
    async function getUserInfo() {
      try {
        const response = await fetch('https://api.spotify.com/v1/me', {
          headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        
        if (!response.ok) throw new Error(`User info failed: ${response.status}`);
        
        const user = await response.json();
        const userNameEl = document.getElementById('user-name');
        if (userNameEl) {
          userNameEl.textContent = user.display_name || 'User';
        }
        
        if (user.product === 'premium') {
          updateStatus('üéµ Initializing...');
          if (spotifyLoginSection) spotifyLoginSection.classList.add('hidden');
          if (musicBar) musicBar.classList.remove('hidden');
          if (window.initializeSpotifyPlayer) {
            window.initializeSpotifyPlayer();
          } else {
            console.warn('initializeSpotifyPlayer not available yet');
          }
        } else {
          updateStatus('‚ö†Ô∏è Premium required', true);
          showPlayerOnly();
        }
        
      } catch (error) {
        updateStatus(`‚ùå ${error.message}`, true);
        showPlayerOnly();
      }
    }
    
    // Make initializeSpotifyPlayer globally accessible
    window.initializeSpotifyPlayer = function() {
      console.log('initializeSpotifyPlayer() called!');
      if (!window.Spotify?.Player) {
        updateStatus('‚è≥ SDK loading...', true);
        return;
      }
      
      spotifyPlayer = new Spotify.Player({
        name: 'GrouchoBarks Player',
        getOAuthToken: cb => cb(accessToken),
        volume: 0.8
      });
      
      spotifyPlayer.addListener('initialization_error', ({ message }) => {
        updateStatus(`‚ùå Init: ${message}`, true);
        console.error('Spotify Init Error:', message);
      });
      spotifyPlayer.addListener('authentication_error', ({ message }) => {
        updateStatus(`‚ùå Auth: ${message}`, true);
        console.error('Spotify Auth Error:', message);
      });
      spotifyPlayer.addListener('account_error', ({ message }) => {
        updateStatus(`‚ùå Account: ${message}`, true);
        console.error('Spotify Account Error:', message);
      });
      spotifyPlayer.addListener('playback_error', ({ message }) => {
        updateStatus(`‚ùå Playback: ${message}`, true);
        console.error('Spotify Playback Error:', message);
      });
      
      spotifyPlayer.addListener('ready', ({ device_id }) => {
        updateStatus('üéµ Ready! Activating device...');
        deviceId = device_id;
        
        sendToCloudflare('info', 'Spotify device ready', {
          deviceId,
          browser: BROWSER_INFO.browser,
          isMobile: BROWSER_INFO.isMobile
        });
        
        // Enhanced device activation with cross-browser conflict handling
        activateDevice(device_id);
      });
      
      async function activateDevice(device_id, stopOthers = true) {
        try {
          // First, get current active devices to log conflicts
          const devicesResponse = await fetch('https://api.spotify.com/v1/me/player/devices', {
            headers: { 'Authorization': `Bearer ${accessToken}` }
          });
          
          if (devicesResponse.ok) {
            const devicesData = await devicesResponse.json();
            const activeDevices = devicesData.devices.filter(d => d.is_active);
            
            sendToCloudflare('debug', 'Active devices before activation', {
              activeDevices: activeDevices.map(d => ({
                name: d.name,
                type: d.type,
                id: d.id,
                is_active: d.is_active
              })),
              newDeviceId: device_id
            });
            
            if (activeDevices.length > 0) {
              updateStatus(`üîÑ Found ${activeDevices.length} active device(s), taking control...`);
            }
          }
          
          // Activate this device and optionally stop others
          const activationResponse = await fetch('https://api.spotify.com/v1/me/player', {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              device_ids: [device_id],
              play: false
            })
          });
          
          if (activationResponse.ok) {
            updateStatus('‚úÖ Device activated!');
            playBtn.disabled = false;
            
            sendToCloudflare('info', 'Device activation successful', {
              deviceId: device_id,
              stopOthers
            });
            
            // Set initial volume after activation
            try {
              await spotifyPlayer.setVolume(0.8);
              updateStatus('üîä Ready to play!');
            } catch (volumeError) {
              updateStatus('üîä Ready to play (volume set failed)');
              sendToCloudflare('warn', 'Volume set failed after activation', {
                error: volumeError.message
              });
            }
            
          } else {
            const errorText = await activationResponse.text();
            updateStatus('‚ö†Ô∏è Device activation failed', true);
            playBtn.disabled = false; // Still allow trying to play
            
            sendToCloudflare('error', 'Device activation failed', {
              status: activationResponse.status,
              error: errorText
            });
          }
          
        } catch (err) {
          updateStatus('‚ö†Ô∏è Device activation error', true);
          console.error('Device activation error:', err);
          playBtn.disabled = false;
          
          sendToCloudflare('error', 'Device activation exception', {
            error: err.message
          });
        }
      }
      
      spotifyPlayer.addListener('player_state_changed', state => {
        console.log('=== STATE CHANGE START ===');
        console.log('userPausedManually at start:', userPausedManually);
        console.log('manualPauseProtectionTime:', manualPauseProtectionTime);
        console.log('Date.now():', Date.now());
        console.log('Protection active?', Date.now() < manualPauseProtectionTime);
        
        if (!state) {
          updateStatus('‚ö†Ô∏è No player state');
          return;
        }
        
        const isPlaying = !state.paused;
        const position = Math.round(state.position / 1000);
        const duration = Math.round(state.duration / 1000);
        
        // Detect if this is a manual pause or auto-pause
        const timeSinceLastPause = Date.now() - pauseRequestTime;
        const positionChanged = Math.abs(position - lastKnownPosition) > 2;
        
        console.log('STATE CHANGE EVENT:', {
          isPlaying,
          position,
          userPausedManually,
          protectionActive: Date.now() < manualPauseProtectionTime,
          protectionTimeLeft: Math.max(0, Math.round((manualPauseProtectionTime - Date.now()) / 1000))
        });
        
        // Only update buttons if not manually paused
        if (!userPausedManually || isPlaying) {
          playBtn.classList.toggle('hidden', isPlaying);
          pauseBtn.classList.toggle('hidden', !isPlaying);
          resumeBtn.classList.add('hidden');
          console.log('Button visibility updated:', {
            userPausedManually,
            isPlaying,
            playBtnHidden: playBtn.classList.contains('hidden'),
            pauseBtnHidden: pauseBtn.classList.contains('hidden'),
            resumeBtnHidden: resumeBtn.classList.contains('hidden')
          });
        } else {
          console.log('Button visibility NOT updated (manual pause preserved):', {
            userPausedManually,
            isPlaying,
            playBtnHidden: playBtn.classList.contains('hidden'),
            pauseBtnHidden: pauseBtn.classList.contains('hidden'),
            resumeBtnHidden: resumeBtn.classList.contains('hidden')
          });
        }
        
        // Detailed debug info
        if (state.track_window.current_track) {
          const track = state.track_window.current_track;
          const restrictions = state.restrictions || {};
          const disallows = state.disallows || {};
          
          let debugInfo = `üéµ ${isPlaying ? 'Playing' : 'Paused'}: ${track.name} (${position}/${duration}s)`;
          
          // Log state change details
          sendToCloudflare('debug', 'Player state changed', {
            isPlaying,
            position,
            duration,
            userPausedManually,
            timeSinceLastPause,
            positionChanged,
            restrictions,
            disallows,
            trackName: track.name
          });
          
          // Check for restrictions that might cause auto-pause
          if (restrictions.disallow_resuming_reasons) {
            debugInfo += ` | Resume blocked: ${restrictions.disallow_resuming_reasons.join(', ')}`;
          }
          if (restrictions.disallow_pausing_reasons) {
            debugInfo += ` | Pause blocked: ${restrictions.disallow_pausing_reasons.join(', ')}`;
          }
          if (disallows.pausing) {
            debugInfo += ` | Pausing disallowed`;
          }
          if (disallows.resuming) {
            debugInfo += ` | Resuming disallowed`;
          }
          
          // Enhanced pause/resume logic
          if (!isPlaying && !userPausedManually && !disallows.resuming && position < duration - 5) {
            // This seems like an auto-pause due to browser policy, not user action
            if (BROWSER_INFO.isMobile && timeSinceLastPause > 3000) {
              debugInfo += ` | üì± Auto-pause detected, preventing auto-resume`;
              sendToCloudflare('warn', 'Auto-pause detected on mobile', {
                position,
                duration,
                timeSinceLastPause
              });
              
              // Don't auto-resume - let user manually resume
              updateStatus('üì± Playback paused - tap ‚ñ∂Ô∏è to continue', true);
            } else if (BROWSER_INFO.browser === 'firefox' && timeSinceLastPause > 1000) {
              debugInfo += ` | ü¶ä Firefox auto-pause detected`;
              sendToCloudflare('warn', 'Firefox auto-pause detected', {
                position,
                duration,
                timeSinceLastPause
              });
            }
          }
          
          // Only reset manual pause flag if we're actually playing and position is advancing
          // AND the protection period has expired
          if (isPlaying && position > lastKnownPosition + 1 && Date.now() > manualPauseProtectionTime) {
            userPausedManually = false;
            console.log('Manual pause flag reset - track playing and progressing');
          } else if (userPausedManually && Date.now() < manualPauseProtectionTime) {
            console.log('Manual pause flag PROTECTED for', Math.round((manualPauseProtectionTime - Date.now()) / 1000), 'more seconds');
          }
          
          lastKnownPosition = position;
          updateStatus(debugInfo);
          
          console.log('Spotify State:', {
            playing: isPlaying,
            position,
            duration,
            restrictions,
            disallows,
            track: track.name,
            userPausedManually,
            timeSinceLastPause
          });
        }
      });
      
      spotifyPlayer.connect();
    };
    
    async function playTestTrack() {
      if (!deviceId) {
        updateStatus('‚ùå Player not ready', true);
        return;
      }
      
      try {
        // Mobile audio context fix - must be triggered by user interaction
        const isMobile = false; // Temporarily disabled: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
          updateStatus('üì± Unlocking mobile audio...');
          
          try {
            // Create and unlock audio context
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            if (audioContext.state === 'suspended') {
              await audioContext.resume();
              updateStatus('üì± Audio context resumed');
            }
            
            // Create audible beep to fully unlock audio
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Brief audible tone to ensure audio is truly unlocked
            oscillator.frequency.value = 440;
            gainNode.gain.value = 0.1;
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
            
            // Wait for the beep to complete
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Now try to resume any suspended Spotify playback
            if (spotifyPlayer) {
              const currentState = await spotifyPlayer.getCurrentState();
              if (currentState && currentState.paused) {
                await spotifyPlayer.resume();
                updateStatus('üì± Spotify resumed after audio unlock');
              }
            }
            
            updateStatus('üì± Mobile audio fully unlocked');
            
          } catch (error) {
            updateStatus(`üì± Audio unlock failed: ${error.message}`, true);
          }
        }
        
        updateStatus('üéµ Activating player element...');
        
        // CRITICAL: Call activateElement() before any playback operations
        if (spotifyPlayer && spotifyPlayer.activateElement) {
          await spotifyPlayer.activateElement();
          updateStatus('‚úÖ Player element activated');
        }
        
        updateStatus('üéµ Starting playback...');
        
        // Device should already be activated, so directly start playing
        const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ uris: [TEST_TRACK_URI] })
        });
        
        if (response.ok) {
          updateStatus('üéµ Playing!');
          
          // Double-click workaround for Safari/mobile - try resume again after a moment
          if (false) { // Disabled mobile check: isMobile
            setTimeout(async () => {
              try {
                if (spotifyPlayer.activateElement) {
                  await spotifyPlayer.activateElement();
                }
                await spotifyPlayer.resume();
                updateStatus('üì± Double-resume applied for mobile');
              } catch (err) {
                console.log('Double-resume failed:', err);
              }
            }, 1000);
          }
          
        } else if (response.status === 404) {
          // Device not active, try to reactivate
          updateStatus('üîÑ Reactivating device...');
          await fetch('https://api.spotify.com/v1/me/player', {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              device_ids: [deviceId],
              play: true,
              uris: [TEST_TRACK_URI]
            })
          });
          updateStatus('üéµ Playing via reactivation!');
        } else {
          const errorText = await response.text();
          updateStatus(`‚ùå Play failed: ${response.status} - ${errorText}`, true);
        }
        
      } catch (error) {
        updateStatus(`‚ùå ${error.message}`, true);
      }
    }
    
    async function pauseTrack() {
      console.log('pauseTrack() function called!');
      if (spotifyPlayer) {
        console.log('spotifyPlayer exists, proceeding with pause');
        // Mark as manual pause and record time
        userPausedManually = true;
        pauseRequestTime = Date.now();
        manualPauseProtectionTime = Date.now() + 2000; // Protect for 2 seconds
        
        console.log('MANUAL PAUSE CLICKED: userPausedManually set to TRUE, protection until', new Date(manualPauseProtectionTime).toLocaleTimeString());
        
        // Set UI first, BEFORE calling spotifyPlayer.pause() which triggers state changes
        pauseBtn.classList.add('hidden');
        resumeBtn.classList.remove('hidden');
        updateStatus('‚è∏Ô∏è Manually paused');
        
        sendToCloudflare('info', 'User manually paused', {
          browser: BROWSER_INFO.browser,
          isMobile: BROWSER_INFO.isMobile,
          timestamp: pauseRequestTime
        });
        
        console.log('About to call spotifyPlayer.pause() - userPausedManually is:', userPausedManually);
        await spotifyPlayer.pause();
        console.log('After spotifyPlayer.pause() - userPausedManually is:', userPausedManually);
      }
    }
    
    async function resumeTrack() {
      if (spotifyPlayer) {
        // Get current state to check if we should resume or restart
        const currentState = await spotifyPlayer.getCurrentState();
        const currentPosition = currentState ? currentState.position : 0;
        const isCurrentlyPaused = currentState ? currentState.paused : true;
        
        console.log('Resume button clicked:', {
          isCurrentlyPaused,
          currentPosition,
          userPausedManually,
          timeSincePause: Date.now() - pauseRequestTime
        });
        
        sendToCloudflare('info', 'User manually resumed', {
          browser: BROWSER_INFO.browser,
          isMobile: BROWSER_INFO.isMobile,
          userPausedManually,
          isCurrentlyPaused,
          currentPosition,
          timeSincePause: Date.now() - pauseRequestTime
        });
        
        // Use normal Spotify SDK resume for all browsers
        try {
          await spotifyPlayer.resume();
          updateStatus('‚ñ∂Ô∏è Resumed');
          
          sendToCloudflare('info', 'Resume successful', {
            browser: BROWSER_INFO.browser,
            method: 'spotifyPlayer.resume()'
          });
        } catch (error) {
          // Fallback: try API resume with explicit position to prevent restart
          try {
            const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                position_ms: currentPosition
              })
            });
            
            if (response.ok) {
              updateStatus('‚ñ∂Ô∏è Resumed via API');
              sendToCloudflare('info', 'Resume fallback successful', {
                browser: BROWSER_INFO.browser,
                method: 'API resume'
              });
            } else {
              throw new Error(`API resume failed: ${response.status}`);
            }
          } catch (apiError) {
            updateStatus('‚ùå Resume failed', true);
            sendToCloudflare('error', 'Resume failed completely', {
              sdkError: error.message,
              apiError: apiError.message
            });
          }
        }
        
        // Reset manual pause tracking
        userPausedManually = false;
        resumeBtn.classList.add('hidden');
        pauseBtn.classList.remove('hidden');
      }
    }
    
    function showPlayerOnly() {
      console.log('showPlayerOnly() called');
      if (spotifyLoginSection) {
        spotifyLoginSection.classList.add('hidden');
        console.log('Spotify login section hidden');
      }
      if (musicBar) {
        musicBar.classList.remove('hidden');
        console.log('Music bar shown');
      }
      updateStatus('üéµ Game ready - music controls available');
    }
    
    function showSpotifyLoginOption() {
      if (spotifyLoginSection) {
        spotifyLoginSection.classList.remove('hidden');
        console.log('Spotify login section shown');
      }
      updateStatus('üéµ Connect Spotify for music playback');
    }
    
    // Event listeners - with null checks
    function setupEventListeners() {
      if (spotifyLoginBtn) spotifyLoginBtn.addEventListener('click', loginWithSpotify);
      if (skipSpotifyBtn) skipSpotifyBtn.addEventListener('click', showPlayerOnly);
      if (playBtn) playBtn.addEventListener('click', playTestTrack);
      if (pauseBtn) {
        pauseBtn.addEventListener('click', function(e) {
          console.log('Pause button clicked! Event:', e);
          pauseTrack();
        });
      }
      if (resumeBtn) resumeBtn.addEventListener('click', resumeTrack);
      
      console.log('Event listeners setup:', {
        spotifyLoginBtn: !!spotifyLoginBtn,
        skipSpotifyBtn: !!skipSpotifyBtn, 
        playBtn: !!playBtn,
        pauseBtn: !!pauseBtn,
        resumeBtn: !!resumeBtn
      });
    }
    
    // Phaser Game Configuration
    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
      }

      create() {
        this.TILE = 48;
        this.COLS = 11;
        this.VIEW_W = this.COLS * this.TILE;
        this.VIEW_H = 500;
        this.SCROLL_SPEED = 96; // Smoother speed - exactly 2 pixels per frame at 48fps

        this.COLOR_BG = 0x363e48;
        this.COLOR_GRID = 0x2b2b32;
        this.COLOR_PATH = 0xd2c1a5;
        this.COLOR_HEDGE = 0x19b23b;
        this.COLOR_LIGHT = 0xd6e482;
        this.COLOR_GRASS = 0x5be37d;

        this.TILE_PATH = 0;
        this.TILE_HEDGE = 1;
        this.TILE_LIGHT = 2;
        this.TILE_GRASS = 3;

        this.VISIBLE_ROWS = Math.ceil(this.VIEW_H / this.TILE) + 6;

        this.leftLightCounter = 0;
        this.rightLightCounter = 0;
        this.leftLightSpacing = Math.floor(Math.random() * 6) + 6;
        this.rightLightSpacing = Math.floor(Math.random() * 6) + 6;
        this.rows = [];

        this.initRows();

        const startCol = Math.floor(this.COLS / 2);
        this.player = this.add.text((startCol + 0.5) * this.TILE, this.VIEW_H * 0.65, 'üëó', {
          fontSize: (this.TILE * 0.85) + 'px'
        }).setOrigin(0.5);

        this.player.currentCol = startCol;
        this.player.lastKeys = {
          left: false, right: false
        };

        this.cursors = this.input.keyboard.createCursorKeys();
        this.aKey = this.input.keyboard.addKey('A');
        this.dKey = this.input.keyboard.addKey('D');
        this.spaceKey = this.input.keyboard.addKey('SPACE');
        
        // Game pause state
        this.isPaused = false;
      }

      update(time, delta) {
        // Handle spacebar pause/resume
        if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
          this.togglePause();
        }
        
        // If paused, don't update game logic
        if (this.isPaused) {
          return;
        }
        
        // Pixel-perfect scrolling to eliminate dithering
        const dy = this.SCROLL_SPEED * (delta / 1000);
        for (const r of this.rows) {
          r.y += dy;
          // Round to nearest pixel to prevent sub-pixel dithering
          r.y = Math.round(r.y);
        }
        this.recycleRowsIfNeeded();
        this.handlePlayerMovement(time);
      }

      initRows() {
        this.rows = [];
        let y = -1;
        for (let i = 0; i < this.VISIBLE_ROWS; i++) {
          this.rows.push(this.makeRow(y));
          y += this.TILE;
        }
      }

      makeRow(y) {
        const g = this.add.graphics();
        const rowData = this.generateRow();
        this.drawRowGraphics(g, rowData);
        const r = { g, rowData, _y: 0 };
        Object.defineProperty(r, 'y', {
          get(){ return this._y; },
          set(v){
            this._y = Math.round(v); // Round to prevent subpixel accumulation
            g.setY(this._y); // Set exact pixel position
          }
        });
        r.y = y;
        return r;
      }

      generateRow() {
        const row = new Array(this.COLS);

        this.leftLightCounter++;
        if (this.leftLightCounter >= this.leftLightSpacing) {
          row[0] = this.TILE_LIGHT;
          this.leftLightCounter = 0;
          this.leftLightSpacing = Math.floor(Math.random() * 6) + 6;
        } else {
          row[0] = this.TILE_HEDGE;
        }

        this.rightLightCounter++;
        if (this.rightLightCounter >= this.rightLightSpacing) {
          row[this.COLS - 1] = this.TILE_LIGHT;
          this.rightLightCounter = 0;
          this.rightLightSpacing = Math.floor(Math.random() * 6) + 6;
        } else {
          row[this.COLS - 1] = this.TILE_HEDGE;
        }

        for (let c = 1; c < this.COLS - 1; c++) {
          if (c >= 4 && c <= 6) {
            row[c] = this.TILE_GRASS;
          } else {
            row[c] = this.TILE_PATH;
          }
        }

        return row;
      }

      drawRowGraphics(g, rowData) {
        g.clear();
        for (let c = 0; c < this.COLS; c++) {
          const x = c * this.TILE;
          const tileType = rowData[c];

          let fillColor;
          switch (tileType) {
            case this.TILE_HEDGE:
              fillColor = this.COLOR_HEDGE;
              break;
            case this.TILE_LIGHT:
              fillColor = this.COLOR_LIGHT;
              break;
            case this.TILE_GRASS:
              fillColor = this.COLOR_GRASS;
              break;
            case this.TILE_PATH:
            default:
              fillColor = this.COLOR_PATH;
              break;
          }
          
          // Fill the tile
          g.fillStyle(fillColor).fillRect(x, 0, this.TILE, this.TILE + 1);
          
          // White borders for better contrast and less flickering
          g.lineStyle(1, 0xffffff, 0.3).strokeRect(x, 0, this.TILE, this.TILE + 1);
        }
      }

      recycleRowsIfNeeded() {
        const bottomLimit = this.VIEW_H + this.TILE * 2;
        let topY = this.rows[0].y;
        for (let i = 1; i < this.rows.length; i++) if (this.rows[i].y < topY) topY = this.rows[i].y;

        for (const r of this.rows) {
          if (r.y >= bottomLimit) {
            r.y = topY - this.TILE;
            r.rowData = this.generateRow();
            this.drawRowGraphics(r.g, r.rowData);
            topY = r.y;
          }
        }
      }

      handlePlayerMovement(time) {
        const leftPressed = this.cursors.left.isDown || this.aKey.isDown;
        const rightPressed = this.cursors.right.isDown || this.dKey.isDown;

        const leftJustPressed = leftPressed && !this.player.lastKeys.left;
        const rightJustPressed = rightPressed && !this.player.lastKeys.right;

        this.player.lastKeys.left = leftPressed;
        this.player.lastKeys.right = rightPressed;

        let hasMoved = false;

        // Only allow horizontal movement, and only on discrete key presses
        if (leftJustPressed && this.player.currentCol > 0) {
          this.player.currentCol--;
          this.player.x = Math.round((this.player.currentCol + 0.5) * this.TILE);
          hasMoved = true;
        } else if (rightJustPressed && this.player.currentCol < this.COLS - 1) {
          this.player.currentCol++;
          this.player.x = Math.round((this.player.currentCol + 0.5) * this.TILE);
          hasMoved = true;
        }

        if (hasMoved) {
          this.checkItemCollection();
        }
      }

      togglePause() {
        this.isPaused = !this.isPaused;
        
        if (this.isPaused) {
          console.log('üéÆ GAME PAUSED - Spacebar pressed');
          updateStatus('‚è∏Ô∏è Game paused (SPACEBAR to resume)');
          
          // Pause Spotify if playing
          if (spotifyPlayer && !userPausedManually) {
            console.log('üéµ Pausing Spotify due to game pause');
            pauseTrack();
          }
        } else {
          console.log('üéÆ GAME RESUMED - Spacebar pressed');
          updateStatus('‚ñ∂Ô∏è Game resumed');
          
          // Resume Spotify if we paused it
          if (spotifyPlayer && userPausedManually) {
            console.log('üéµ Resuming Spotify due to game resume');
            resumeTrack();
          }
        }
      }

      checkItemCollection() {
        const playerRow = Math.floor(this.player.y / this.TILE);
        const playerCol = this.player.currentCol;

        if (playerCol < 0 || playerCol >= this.COLS) {
          return;
        }

        for (const row of this.rows) {
          const rowIndex = Math.floor((row.y + this.TILE / 2) / this.TILE);
          if (rowIndex === playerRow) {
            if (row.rowData[playerCol] === this.TILE_LIGHT) {
              row.rowData[playerCol] = this.TILE_PATH;
              this.drawRowGraphics(row.g, row.rowData);
              // Subtle flash effect - shorter duration, less intense
              this.cameras.main.flash(50, 255, 255, 100, false, 0.05);
            }
            break;
          }
        }
      }
    }

    const GameConfig = {
      type: Phaser.AUTO,
      parent: 'game',
      width: 528,   // Fixed width: 11 * 48px
      height: 500,  // Fixed height
      backgroundColor: 0x363e48,
      physics: { default: 'arcade' },
      scale: { 
        mode: Phaser.Scale.NONE,  // No scaling
        autoCenter: Phaser.Scale.NO_CENTER  // No auto-centering
      },
      render: { pixelArt: true, antialias: false, roundPixels: true },
      scene: GameScene
    };

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      // Setup event listeners first
      setupEventListeners();
      
      // Start the Phaser game
      const game = new Phaser.Game(GameConfig);
      
      // Handle OAuth callback
      if (window.location.search.includes('code=')) {
        console.log('üîÑ Processing OAuth callback...');
        handleCallback();
        return;
      }
      
      // Check for existing session or test token
      const savedToken = sessionStorage.getItem('spotify_access_token');
      if (savedToken) {
        accessToken = savedToken;
        updateStatus('üîë Found saved session...');
        getUserInfo();
      } else {
        // No token found - show login option unless we're in test mode
        const hasTestToken = window.TEST_SPOTIFY_TOKEN && 
                           window.TEST_SPOTIFY_TOKEN !== 'PASTE_YOUR_TOKEN_HERE' &&
                           window.TEST_SPOTIFY_TOKEN.length > 100;
        
        if (!hasTestToken) {
          // Show Spotify login option inline
          showSpotifyLoginOption();
        } else {
          // Test token will be injected, just show player
          showPlayerOnly();
        }
      }
    });
    
    // Spotify SDK ready callback is now defined in the head section
  </script>
</body>
</html>