<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>GrouchoBarks Audio Player</title>
  <script src="https://sdk.scdn.co/spotify-player.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1db954, #191414);
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    
    #music-bar {
      position: relative;
      bottom: auto;
      left: auto;
      right: auto;
      width: 90%;
      max-width: 600px;
      height: 80px;
      background: linear-gradient(90deg, #1db954, #1ed760);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 30px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      border-radius: 15px;
      z-index: 1000;
      margin: 20px 0;
    }
    
    .player-section {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .music-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .music-btn:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.1);
    }
    
    .music-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .track-info {
      color: white;
      font-size: 14px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    
    .user-info {
      color: white;
      font-size: 12px;
      opacity: 0.8;
    }
    
    .status {
      color: white;
      font-size: 12px;
      opacity: 0.9;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    @media (max-width: 768px) {
      .status {
        font-size: 14px;
        max-width: calc(100vw - 20px);
        top: 60px !important;
        left: 10px !important;
        right: 10px !important;
        white-space: normal;
        word-wrap: break-word;
      }
    }
    
    .hidden {
      display: none;
    }
    
    /* Player title */
    .player-title {
      color: white;
      font-size: 28px;
      font-weight: bold;
      text-align: center;
      margin: 20px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    /* Compact login overlay */
    #login-overlay {
      background: rgba(0,0,0,0.9);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 2000;
      color: white;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    
    #login-overlay button {
      background: #1db954;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px;
    }
    
    #login-overlay button:hover {
      background: #1ed760;
    }
  </style>
</head>
<body>
  <!-- Player Title -->
  <h1 class="player-title">üéµ GrouchoBarks Audio Player <span style="font-size: 14px; opacity: 0.8;">v2.1.3</span></h1>
  
  <!-- Compact Login Overlay -->
  <div id="login-overlay">
    <h2>üéµ Connect Spotify?</h2>
    <p>Test audio playback across browsers</p>
    <button id="login-btn">üéµ Login to Spotify</button>
    <button id="skip-btn">üì± Test Without Login</button>
  </div>
  
  <!-- Compact Music Bar -->
  <div id="music-bar" class="hidden">
    <!-- Left: Controls -->
    <div class="player-section">
      <button id="play-btn" class="music-btn" disabled title="Play">‚ñ∂Ô∏è</button>
      <button id="pause-btn" class="music-btn hidden" title="Pause">‚è∏Ô∏è</button>
      <button id="resume-btn" class="music-btn hidden" title="Resume">‚ñ∂Ô∏è</button>
      <button id="volume-btn" class="music-btn" title="Diagnostic Info">üìä</button>
      <button id="audio-unlock-btn" class="music-btn" title="Force Audio Unlock">üîì</button>
      <button id="clear-btn" class="music-btn" title="Clear Data">üßπ</button>
    </div>
    
    <!-- Center: Track Info -->
    <div class="track-info" id="track-info">
      Fratty Pipeline üéµ
    </div>
    
    <!-- Right: User & Status -->
    <div class="player-section">
      <div class="user-info" id="user-info">üéß <span id="user-name">--</span></div>
      <div class="user-info" style="font-size: 14px; font-weight: bold; color: #1db954;">Audio Only</div>
      <button id="logout-btn" class="music-btn" title="Logout">üö™</button>
    </div>
  </div>
  
  <!-- Status (floating) -->
  <div id="status" class="status" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1001; text-align: center;"></div>
  <script>
    // Version and browser info
    const VERSION = '2.1.3';
    const BROWSER_INFO = {
      userAgent: navigator.userAgent,
      isMobile: false, // Temporarily disabled: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent),
      isIOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),
      isAndroid: /Android/i.test(navigator.userAgent),
      browser: (() => {
        const ua = navigator.userAgent.toLowerCase();
        if (ua.includes('chrome') && !ua.includes('edg')) return 'chrome';
        if (ua.includes('safari') && !ua.includes('chrome')) return 'safari';
        if (ua.includes('firefox')) return 'firefox';
        return 'other';
      })()
    };

    // External logging setup
    const LOG_ENDPOINT = `${window.location.origin}/log`; // Cloudflare Pages Function
    let logBuffer = [];
    
    async function sendToCloudflare(level, message, data = {}) {
      const logEntry = {
        timestamp: new Date().toISOString(),
        version: VERSION,
        level,
        message,
        browser: BROWSER_INFO,
        url: window.location.href,
        data
      };
      
      logBuffer.push(logEntry);
      
      // Send to external service (enable when ready)
      try {
        await fetch(LOG_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(logEntry)
        });
      } catch (error) {
        // Silent fail - store locally instead
        localStorage.setItem('debug_logs', JSON.stringify(logBuffer.slice(-50))); // Keep last 50 entries
      }
    }

    // Define updateStatus early with logging
    function updateStatus(message, isError = false) {
      const statusDiv = document.getElementById('status');
      if (statusDiv) {
        statusDiv.textContent = message;
        statusDiv.style.color = isError ? '#ff6b6b' : '#1db954';
        console.log(message);
        
        // Send to external logging
        sendToCloudflare(isError ? 'error' : 'info', message);
        
        // Keep debugging messages longer on mobile
        const timeout = BROWSER_INFO.isMobile ? 8000 : 3000;
        
        setTimeout(() => { statusDiv.textContent = ''; }, timeout);
      }
    }
    // Spotify credentials
    const CLIENT_ID = 'aa16f7f72c04485fb93d86d2f7ee33d1';
    const REDIRECT_URI = 'https://frattypipeline.grouchobarks.bandmusicgames.party';
    const SCOPES = 'user-read-private user-read-email user-modify-playback-state user-read-playback-state streaming';
    const TEST_TRACK_URI = 'spotify:track:33lVSu93J91BDmhfRT7iTA';
    
    let accessToken = null;
    let spotifyPlayer = null;
    let deviceId = null;
    
    // UI Elements
    const loginOverlay = document.getElementById('login-overlay');
    const musicBar = document.getElementById('music-bar');
    const statusDiv = document.getElementById('status');
    const loginBtn = document.getElementById('login-btn');
    const skipBtn = document.getElementById('skip-btn');
    const playBtn = document.getElementById('play-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const volumeBtn = document.getElementById('volume-btn');
    const audioUnlockBtn = document.getElementById('audio-unlock-btn');
    const clearBtn = document.getElementById('clear-btn');
    const logoutBtn = document.getElementById('logout-btn');
    
    // updateStatus already defined above
    
    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const values = crypto.getRandomValues(new Uint8Array(length));
      return values.reduce((acc, x) => acc + possible[x % possible.length], "");
    }
    
    async function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return window.crypto.subtle.digest('SHA-256', data);
    }
    
    function base64encode(input) {
      return btoa(String.fromCharCode(...new Uint8Array(input)))
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
    }
    
    async function loginWithSpotify() {
      updateStatus('üéµ Starting login...');
      
      const codeVerifier = generateRandomString(64);
      const hashed = await sha256(codeVerifier);
      const codeChallenge = base64encode(hashed);
      
      localStorage.setItem('code_verifier', codeVerifier);
      
      const authUrl = new URL('https://accounts.spotify.com/authorize');
      authUrl.searchParams.append('response_type', 'code');
      authUrl.searchParams.append('client_id', CLIENT_ID);
      authUrl.searchParams.append('scope', SCOPES);
      authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
      authUrl.searchParams.append('code_challenge_method', 'S256');
      authUrl.searchParams.append('code_challenge', codeChallenge);
      
      window.location.href = authUrl.toString();
    }
    
    async function handleCallback() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      const error = urlParams.get('error');
      
      if (error) {
        updateStatus(`‚ùå ${error}`, true);
        showPlayerOnly();
        return;
      }
      
      if (code) {
        updateStatus('üîë Getting token...');
        await exchangeCodeForToken(code);
      }
    }
    
    async function exchangeCodeForToken(code) {
      const codeVerifier = localStorage.getItem('code_verifier');
      
      if (!codeVerifier) {
        updateStatus('‚ùå No code verifier found', true);
        // Clear the URL and start fresh
        window.history.replaceState({}, document.title, window.location.pathname);
        showPlayerOnly();
        return;
      }
      
      try {
        updateStatus('üîÑ Exchanging code for token...');
        
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Token failed: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        accessToken = data.access_token;
        
        sessionStorage.setItem('spotify_access_token', accessToken);
        localStorage.removeItem('code_verifier');
        window.history.replaceState({}, document.title, window.location.pathname);
        
        updateStatus('‚úÖ Token OK');
        await getUserInfo();
        
      } catch (error) {
        updateStatus(`‚ùå ${error.message}`, true);
        // Clear the URL and start fresh
        window.history.replaceState({}, document.title, window.location.pathname);
        showPlayerOnly();
      }
    }
    
    async function getUserInfo() {
      try {
        const response = await fetch('https://api.spotify.com/v1/me', {
          headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        
        if (!response.ok) throw new Error(`User info failed: ${response.status}`);
        
        const user = await response.json();
        document.getElementById('user-name').textContent = user.display_name || 'User';
        
        if (user.product === 'premium') {
          updateStatus('üéµ Initializing...');
          loginOverlay.classList.add('hidden');
          musicBar.classList.remove('hidden');
          initializeSpotifyPlayer();
        } else {
          updateStatus('‚ö†Ô∏è Premium required', true);
          showPlayerOnly();
        }
        
      } catch (error) {
        updateStatus(`‚ùå ${error.message}`, true);
        showPlayerOnly();
      }
    }
    
    function initializeSpotifyPlayer() {
      if (!window.Spotify?.Player) {
        updateStatus('‚è≥ SDK loading...', true);
        return;
      }
      
      spotifyPlayer = new Spotify.Player({
        name: 'GrouchoBarks Player',
        getOAuthToken: cb => cb(accessToken),
        volume: 0.8
      });
      
      spotifyPlayer.addListener('initialization_error', ({ message }) => {
        updateStatus(`‚ùå Init: ${message}`, true);
        console.error('Spotify Init Error:', message);
      });
      spotifyPlayer.addListener('authentication_error', ({ message }) => {
        updateStatus(`‚ùå Auth: ${message}`, true);
        console.error('Spotify Auth Error:', message);
      });
      spotifyPlayer.addListener('account_error', ({ message }) => {
        updateStatus(`‚ùå Account: ${message}`, true);
        console.error('Spotify Account Error:', message);
      });
      spotifyPlayer.addListener('playback_error', ({ message }) => {
        updateStatus(`‚ùå Playback: ${message}`, true);
        console.error('Spotify Playback Error:', message);
      });
      
      spotifyPlayer.addListener('ready', ({ device_id }) => {
        updateStatus('üéµ Ready! Activating device...');
        deviceId = device_id;
        
        sendToCloudflare('info', 'Spotify device ready', {
          deviceId,
          browser: BROWSER_INFO.browser,
          isMobile: BROWSER_INFO.isMobile
        });
        
        // Enhanced device activation with cross-browser conflict handling
        activateDevice(device_id);
      });
      
      async function activateDevice(device_id, stopOthers = true) {
        try {
          // First, get current active devices to log conflicts
          const devicesResponse = await fetch('https://api.spotify.com/v1/me/player/devices', {
            headers: { 'Authorization': `Bearer ${accessToken}` }
          });
          
          if (devicesResponse.ok) {
            const devicesData = await devicesResponse.json();
            const activeDevices = devicesData.devices.filter(d => d.is_active);
            
            sendToCloudflare('debug', 'Active devices before activation', {
              activeDevices: activeDevices.map(d => ({
                name: d.name,
                type: d.type,
                id: d.id,
                is_active: d.is_active
              })),
              newDeviceId: device_id
            });
            
            if (activeDevices.length > 0) {
              updateStatus(`üîÑ Found ${activeDevices.length} active device(s), taking control...`);
            }
          }
          
          // Activate this device and optionally stop others
          const activationResponse = await fetch('https://api.spotify.com/v1/me/player', {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              device_ids: [device_id],
              play: false
            })
          });
          
          if (activationResponse.ok) {
            updateStatus('‚úÖ Device activated!');
            playBtn.disabled = false;
            
            sendToCloudflare('info', 'Device activation successful', {
              deviceId: device_id,
              stopOthers
            });
            
            // Set initial volume after activation
            try {
              await spotifyPlayer.setVolume(0.8);
              updateStatus('üîä Ready to play!');
            } catch (volumeError) {
              updateStatus('üîä Ready to play (volume set failed)');
              sendToCloudflare('warn', 'Volume set failed after activation', {
                error: volumeError.message
              });
            }
            
          } else {
            const errorText = await activationResponse.text();
            updateStatus('‚ö†Ô∏è Device activation failed', true);
            playBtn.disabled = false; // Still allow trying to play
            
            sendToCloudflare('error', 'Device activation failed', {
              status: activationResponse.status,
              error: errorText
            });
          }
          
        } catch (err) {
          updateStatus('‚ö†Ô∏è Device activation error', true);
          console.error('Device activation error:', err);
          playBtn.disabled = false;
          
          sendToCloudflare('error', 'Device activation exception', {
            error: err.message
          });
        }
      }
      
      // Enhanced state tracking
      let userPausedManually = false;
      let lastKnownPosition = 0;
      let pauseRequestTime = 0;
      
      spotifyPlayer.addListener('player_state_changed', state => {
        if (!state) {
          updateStatus('‚ö†Ô∏è No player state');
          return;
        }
        
        const isPlaying = !state.paused;
        const position = Math.round(state.position / 1000);
        const duration = Math.round(state.duration / 1000);
        
        // Detect if this is a manual pause or auto-pause
        const timeSinceLastPause = Date.now() - pauseRequestTime;
        const positionChanged = Math.abs(position - lastKnownPosition) > 2;
        
        // Only update buttons if not manually paused
        if (!userPausedManually || isPlaying) {
          playBtn.classList.toggle('hidden', isPlaying);
          pauseBtn.classList.toggle('hidden', !isPlaying);
          resumeBtn.classList.add('hidden');
          console.log('Button visibility updated:', {
            userPausedManually,
            isPlaying,
            playBtnHidden: playBtn.classList.contains('hidden'),
            pauseBtnHidden: pauseBtn.classList.contains('hidden'),
            resumeBtnHidden: resumeBtn.classList.contains('hidden')
          });
        } else {
          console.log('Button visibility NOT updated (manual pause preserved):', {
            userPausedManually,
            isPlaying,
            playBtnHidden: playBtn.classList.contains('hidden'),
            pauseBtnHidden: pauseBtn.classList.contains('hidden'),
            resumeBtnHidden: resumeBtn.classList.contains('hidden')
          });
        }
        
        // Detailed debug info
        if (state.track_window.current_track) {
          const track = state.track_window.current_track;
          const restrictions = state.restrictions || {};
          const disallows = state.disallows || {};
          
          let debugInfo = `üéµ ${isPlaying ? 'Playing' : 'Paused'}: ${track.name} (${position}/${duration}s)`;
          
          // Log state change details
          sendToCloudflare('debug', 'Player state changed', {
            isPlaying,
            position,
            duration,
            userPausedManually,
            timeSinceLastPause,
            positionChanged,
            restrictions,
            disallows,
            trackName: track.name
          });
          
          // Check for restrictions that might cause auto-pause
          if (restrictions.disallow_resuming_reasons) {
            debugInfo += ` | Resume blocked: ${restrictions.disallow_resuming_reasons.join(', ')}`;
          }
          if (restrictions.disallow_pausing_reasons) {
            debugInfo += ` | Pause blocked: ${restrictions.disallow_pausing_reasons.join(', ')}`;
          }
          if (disallows.pausing) {
            debugInfo += ` | Pausing disallowed`;
          }
          if (disallows.resuming) {
            debugInfo += ` | Resuming disallowed`;
          }
          
          // Enhanced pause/resume logic
          if (!isPlaying && !userPausedManually && !disallows.resuming && position < duration - 5) {
            // This seems like an auto-pause due to browser policy, not user action
            if (BROWSER_INFO.isMobile && timeSinceLastPause > 3000) {
              debugInfo += ` | üì± Auto-pause detected, preventing auto-resume`;
              sendToCloudflare('warn', 'Auto-pause detected on mobile', {
                position,
                duration,
                timeSinceLastPause
              });
              
              // Don't auto-resume - let user manually resume
              updateStatus('üì± Playback paused - tap ‚ñ∂Ô∏è to continue', true);
            } else if (BROWSER_INFO.browser === 'firefox' && timeSinceLastPause > 1000) {
              debugInfo += ` | ü¶ä Firefox auto-pause detected`;
              sendToCloudflare('warn', 'Firefox auto-pause detected', {
                position,
                duration,
                timeSinceLastPause
              });
            }
          }
          
          // Only reset manual pause flag if we're actually playing and enough time passed
          if (isPlaying && timeSinceLastPause > 1000) {
            userPausedManually = false;
          }
          
          lastKnownPosition = position;
          updateStatus(debugInfo);
          
          console.log('Spotify State:', {
            playing: isPlaying,
            position,
            duration,
            restrictions,
            disallows,
            track: track.name,
            userPausedManually,
            timeSinceLastPause
          });
        }
      });
      
      spotifyPlayer.connect();
    }
    
    async function playTestTrack() {
      if (!deviceId) {
        updateStatus('‚ùå Player not ready', true);
        return;
      }
      
      try {
        // Mobile audio context fix - must be triggered by user interaction
        const isMobile = false; // Temporarily disabled: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
          updateStatus('üì± Unlocking mobile audio...');
          
          try {
            // Create and unlock audio context
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            if (audioContext.state === 'suspended') {
              await audioContext.resume();
              updateStatus('üì± Audio context resumed');
            }
            
            // Create audible beep to fully unlock audio
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Brief audible tone to ensure audio is truly unlocked
            oscillator.frequency.value = 440;
            gainNode.gain.value = 0.1;
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
            
            // Wait for the beep to complete
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Now try to resume any suspended Spotify playback
            if (spotifyPlayer) {
              const currentState = await spotifyPlayer.getCurrentState();
              if (currentState && currentState.paused) {
                await spotifyPlayer.resume();
                updateStatus('üì± Spotify resumed after audio unlock');
              }
            }
            
            updateStatus('üì± Mobile audio fully unlocked');
            
          } catch (error) {
            updateStatus(`üì± Audio unlock failed: ${error.message}`, true);
          }
        }
        
        updateStatus('üéµ Activating player element...');
        
        // CRITICAL: Call activateElement() before any playback operations
        if (spotifyPlayer && spotifyPlayer.activateElement) {
          await spotifyPlayer.activateElement();
          updateStatus('‚úÖ Player element activated');
        }
        
        updateStatus('üéµ Starting playback...');
        
        // Device should already be activated, so directly start playing
        const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ uris: [TEST_TRACK_URI] })
        });
        
        if (response.ok) {
          updateStatus('üéµ Playing!');
          
          // Double-click workaround for Safari/mobile - try resume again after a moment
          if (false) { // Disabled mobile check: isMobile
            setTimeout(async () => {
              try {
                if (spotifyPlayer.activateElement) {
                  await spotifyPlayer.activateElement();
                }
                await spotifyPlayer.resume();
                updateStatus('üì± Double-resume applied for mobile');
              } catch (err) {
                console.log('Double-resume failed:', err);
              }
            }, 1000);
          }
          
        } else if (response.status === 404) {
          // Device not active, try to reactivate
          updateStatus('üîÑ Reactivating device...');
          await fetch('https://api.spotify.com/v1/me/player', {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              device_ids: [deviceId],
              play: true,
              uris: [TEST_TRACK_URI]
            })
          });
          updateStatus('üéµ Playing via reactivation!');
        } else {
          const errorText = await response.text();
          updateStatus(`‚ùå Play failed: ${response.status} - ${errorText}`, true);
        }
        
      } catch (error) {
        updateStatus(`‚ùå ${error.message}`, true);
      }
    }
    
    async function pauseTrack() {
      if (spotifyPlayer) {
        // Mark as manual pause and record time
        userPausedManually = true;
        pauseRequestTime = Date.now();
        
        sendToCloudflare('info', 'User manually paused', {
          browser: BROWSER_INFO.browser,
          isMobile: BROWSER_INFO.isMobile,
          timestamp: pauseRequestTime
        });
        
        await spotifyPlayer.pause();
        updateStatus('‚è∏Ô∏è Manually paused');
        pauseBtn.classList.add('hidden');
        resumeBtn.classList.remove('hidden');
      }
    }
    
    async function resumeTrack() {
      if (spotifyPlayer) {
        // Get current state to check if we should resume or restart
        const currentState = await spotifyPlayer.getCurrentState();
        const currentPosition = currentState ? currentState.position : 0;
        const isCurrentlyPaused = currentState ? currentState.paused : true;
        
        console.log('Resume button clicked:', {
          isCurrentlyPaused,
          currentPosition,
          userPausedManually,
          timeSincePause: Date.now() - pauseRequestTime
        });
        
        sendToCloudflare('info', 'User manually resumed', {
          browser: BROWSER_INFO.browser,
          isMobile: BROWSER_INFO.isMobile,
          userPausedManually,
          isCurrentlyPaused,
          currentPosition,
          timeSincePause: Date.now() - pauseRequestTime
        });
        
        // Use normal Spotify SDK resume for all browsers
        try {
          await spotifyPlayer.resume();
          updateStatus('‚ñ∂Ô∏è Resumed');
          
          sendToCloudflare('info', 'Resume successful', {
            browser: BROWSER_INFO.browser,
            method: 'spotifyPlayer.resume()'
          });
        } catch (error) {
          // Fallback: try API resume with explicit position to prevent restart
          try {
            const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                position_ms: currentPosition
              })
            });
            
            if (response.ok) {
              updateStatus('‚ñ∂Ô∏è Resumed via API');
              sendToCloudflare('info', 'Resume fallback successful', {
                browser: BROWSER_INFO.browser,
                method: 'API resume'
              });
            } else {
              throw new Error(`API resume failed: ${response.status}`);
            }
          } catch (apiError) {
            updateStatus('‚ùå Resume failed', true);
            sendToCloudflare('error', 'Resume failed completely', {
              sdkError: error.message,
              apiError: apiError.message
            });
          }
        }
        
        // Reset manual pause tracking
        userPausedManually = false;
        resumeBtn.classList.add('hidden');
        pauseBtn.classList.remove('hidden');
      }
    }
    
    async function testVolume() {
      if (!spotifyPlayer) {
        updateStatus('‚ùå Player not ready', true);
        return;
      }
      
      try {
        // Get current player state from Spotify API
        const stateResponse = await fetch('https://api.spotify.com/v1/me/player', {
          headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        
        if (stateResponse.ok) {
          const state = await stateResponse.json();
          updateStatus(`üìä API State: ${state.is_playing ? 'Playing' : 'Paused'} on ${state.device.name} (${state.device.type})`);
        } else {
          updateStatus('üìä No active playback found');
        }
        
        // Get current volume from Web Playback SDK
        const volume = await spotifyPlayer.getVolume();
        updateStatus(`üîä SDK Volume: ${Math.round(volume * 100)}%`);
        
        // Get current state from Web Playback SDK
        const sdkState = await spotifyPlayer.getCurrentState();
        if (sdkState) {
          const track = sdkState.track_window.current_track;
          updateStatus(`üéµ SDK State: ${sdkState.paused ? 'Paused' : 'Playing'} - ${track ? track.name : 'No track'}`);
        } else {
          updateStatus('‚ö†Ô∏è No SDK state available');
        }
        
        // Try to set volume to max for mobile
        await spotifyPlayer.setVolume(1.0);
        updateStatus('üîä Volume set to 100%');
        
      } catch (error) {
        updateStatus(`‚ùå Diagnostic error: ${error.message}`, true);
      }
    }
    
    async function forceAudioUnlock() {
      updateStatus('üîì Force unlocking audio...');
      
      try {
        // Create audio context and force interaction
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
          updateStatus('üîì Audio context force resumed');
        }
        
        // Play a short audible beep to ensure audio works
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800; // Higher pitch beep
        gainNode.gain.value = 0.2; // Louder
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.3); // Longer beep
        
        await new Promise(resolve => setTimeout(resolve, 400));
        
        // Force Spotify to restart if it's stuck
        if (spotifyPlayer) {
          // CRITICAL: Activate element first
          if (spotifyPlayer.activateElement) {
            await spotifyPlayer.activateElement();
            updateStatus('üîì Player element activated');
          }
          
          const currentState = await spotifyPlayer.getCurrentState();
          if (currentState) {
            await spotifyPlayer.setVolume(1.0);
            if (currentState.paused) {
              await spotifyPlayer.resume();
              updateStatus('üîì Forced Spotify resume');
            } else {
              // If playing but no audio, try pause then resume
              await spotifyPlayer.pause();
              await new Promise(resolve => setTimeout(resolve, 500));
              await spotifyPlayer.resume();
              updateStatus('üîì Forced Spotify restart');
            }
          }
        }
        
        updateStatus('üîì Audio unlock complete - try playing now!');
        
      } catch (error) {
        updateStatus(`üîì Force unlock failed: ${error.message}`, true);
      }
    }
    
    function logout() {
      accessToken = null;
      sessionStorage.removeItem('spotify_access_token');
      
      if (spotifyPlayer) {
        spotifyPlayer.disconnect();
        spotifyPlayer = null;
      }
      
      musicBar.classList.add('hidden');
      loginOverlay.classList.remove('hidden');
      updateStatus('üëã Logged out');
    }
    
    function showPlayerOnly() {
      loginOverlay.classList.add('hidden');
      musicBar.classList.remove('hidden');
      updateStatus('üéµ Audio player ready - test your browser compatibility!');
    }
    
    // Event listeners
    loginBtn.addEventListener('click', loginWithSpotify);
    skipBtn.addEventListener('click', showPlayerOnly);
    playBtn.addEventListener('click', playTestTrack);
    pauseBtn.addEventListener('click', pauseTrack);
    resumeBtn.addEventListener('click', resumeTrack);
    volumeBtn.addEventListener('click', testVolume);
    audioUnlockBtn.addEventListener('click', forceAudioUnlock);
    clearBtn.addEventListener('click', clearAllData);
    logoutBtn.addEventListener('click', logout);
    
    // Manual cache clearing function
    function clearAllData() {
      // Clear localStorage
      localStorage.clear();
      
      // Clear sessionStorage  
      sessionStorage.clear();
      
      // Clear all cookies
      document.cookie.split(";").forEach(function(c) { 
        document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); 
      });
      
      updateStatus('üßπ Cleared all data - please refresh page');
      
      // Reload page after a moment
      setTimeout(() => {
        window.location.reload();
      }, 1500);
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      if (window.location.search.includes('code=')) {
        handleCallback();
        return;
      }
      
      // Check for existing session
      const savedToken = sessionStorage.getItem('spotify_access_token');
      if (savedToken) {
        accessToken = savedToken;
        updateStatus('üîë Found saved session...');
        getUserInfo();
      }
    });
    
    // Spotify SDK ready callback (must be in global scope)
    window.onSpotifyWebPlaybackSDKReady = () => {
      updateStatus('üéµ SDK ready');
      if (accessToken) {
        initializeSpotifyPlayer();
      }
    };
  </script>
</body>
</html>